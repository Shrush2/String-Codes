import java.util.* ;
import java.io.*; 
public class Solution {
	public static String specialString(String s, int n, int p) {
		// Write your code here.

		char arr[] = s.toCharArray();
		for(int i = n-1; i >= 0; i--){
			for(char next = (char)(arr[i]+1); next < (char)('a'+p); next++){
				if(isValid(arr,i,next)){
					arr[i] = next;


					for(int j = i+1; j < n;j++){
						for(char ch = 'a' ; ch < (char)('a'+p);ch++){
							if(isValid(arr,j,ch)){
								arr[j] = ch;
								break;
							}
						}
					}
					return new String(arr);
				}
			}
			
		}

		return "NO";
	}

	public static boolean isValid(char arr[],int i,char ch){
			if(i > 0 && arr[i-1] == ch)return false;
			if(i > 1 && arr[i-2] == ch)return false;

			return true;

		}
}

A string â€˜Sâ€™ is said to be special if each of its characters is one of the first â€˜Pâ€™ letters of the English alphabet and â€˜Sâ€™ doesn't contain any palindrome contiguous substring of length 2 or more. You will be given a
special string â€˜Sâ€™ of length â€˜Nâ€™, find the lexicographically next special string of the same length, or else state that such string does not exist. Print the output string if it exists, otherwise, print "NO" 
(without quotes).
A string â€œs1â€ is a substring of another string â€œs2â€ if â€œs2â€ contains the same characters as in â€œs1â€, in the same order and in a continuous fashion also.

Example: Given a string â€œcbaâ€ and â€˜Pâ€™ equals 3. So, the next strings which are lexicographically bigger than string â€˜Sâ€™ are â€œcbbâ€, â€œcbcâ€, â€œccaâ€, â€œccbâ€ and â€œcccâ€ of size 3. But all of them have a palindrome 
substring of the size at least 2. So, we will return â€œNOâ€ as output. If the given string is â€œcbdâ€ and â€˜Pâ€™ equals 4 then the next string will be â€œcdaâ€ and it is special. So, we can return an output here.


N = 4, P = 4  
S = "abcd"
Allowed letters = {a, b, c, d}

Step 1: Start from the end

We loop i = n-1 â†’ 3 (character 'd').

Try to increment 'd':

'd' + 1 = 'e' â†’ but loop condition is next < 'a' + p = 'a' + 4 = 'e'.

Since next == 'e' is not < 'e', no valid char.
So index 3 fails.

Step 2: Move to index 2 ('c')

Try to increment 'c':

'c' + 1 = 'd'.

'd' < 'e' âœ… allowed.

Check isValid:

At i=2: previous chars are "ab".

'b' != 'd' (good).

No "aba" pattern (good).
So we can set arr[2] = 'd'.

Now the string looks like:
ğŸ‘‰ "abd?"

Step 3: Fill remaining positions (j = 3)

We try smallest allowed chars (aâ€¦d):

Try 'a':

At j=3: previous = "d", two before = "b".

'd' != 'a' âœ…, 'b' != 'a' âœ….
So 'a' is valid.

Now the string is:
ğŸ‘‰ "abda"


T.C => O(n * O(p + n*p))
SC => O(N)
